local function waitForResume() gg.toast("Script paused. Click GG icon to resume", true) while not gg.isVisible() do gg.sleep(100) end gg.setVisible(false) end -- For search steps: if cancelled, exit to main menu. local function safePromptSearch(prompts, defaults, types) local input = gg.prompt(prompts, defaults, types) if input == nil then gg.toast("Returning to main menu...", true) waitForResume() return nil end return input end local function safeChoiceSearch(items, default, title) local choice = gg.choice(items, default, title) if choice == nil then gg.toast("Returning to main menu...", true) waitForResume() return nil end return choice end -- For numeric input steps: if cancelled, loop until valid input is provided. local function safePromptLoop(prompts, defaults, types) local input = gg.prompt(prompts, defaults, types) while input == nil do gg.toast("Script paused. Click GG icon to resume", true) waitForResume() input = gg.prompt(prompts, defaults, types) end return input end local function fetchDragonData() local response = gg.makeRequest("https://dragoncitytips.com/thien") if not response or not response.content then gg.alert("Failed to download dragon data!") return nil end local data = {} for match in response.content:gmatch("(.-)") do local cleaned = match:gsub("<[^>]+>", ""):gsub("-", ""):gsub("^%s+", ""):gsub("%s+$", "") if cleaned:match("^%d") then local code, name = cleaned:match("^(%d+)%s+(.+)$") if code and name then table.insert(data, {code = code, name = name}) end end end return #data > 0 and data or nil end local globalDragonData = fetchDragonData() local function getDragonNameFromCode(code) if not globalDragonData then return "Undefined Dragon" end for _, dragon in ipairs(globalDragonData) do if dragon.code == tostring(code) then return dragon.name end end return "Undefined Dragon" end local function searchDragonCode() if not globalDragonData then globalDragonData = fetchDragonData() if not globalDragonData then return nil end end local input = safePromptSearch({"Enter dragon name:"}, {""}, {"text"}) if input == nil then return nil -- Exit immediately if cancelled. end local searchTerm = input[1]:lower() local matches, codes = {}, {} for _, dragon in ipairs(globalDragonData) do if dragon.name:lower():find(searchTerm, 1, true) then table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name) table.insert(codes, dragon.code) end end if #matches == 0 then gg.alert("No dragons found for: " .. searchTerm) return nil end -- Loop until a valid selection is made. local choice = nil repeat choice = gg.choice(matches, nil, "Select Dragon") if choice == nil then gg.toast("Selection paused. Tap GG icon to resume.", true) waitForResume() end until choice ~= nil return codes[choice] end -------------------------------------------------- -- Original Mod Feature Implementations --------------------------------------------------
local function getTeamData(id) local url = "https://dragoncitytips.com/scripts/checkteam?id=" .. id local http = gg.makeRequest(url) if not http or not http.content then gg.alert("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ API!") return nil end -- X·ª≠ l√Ω l·ªói b·ªã ch√®n v√†o local content = http.content:gsub("", "\n") -- Thay b·∫±ng xu·ªëng d√≤ng local lines = {} for line in content:gmatch("[^\r\n]+") do table.insert(lines, line) end if #lines < 5 then gg.alert("D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá!") return nil end return { dragonCode = lines[1], firstDragonLevel = tonumber(lines[2]) or 1, firstDragonGrade = tonumber(lines[3]) or 1, secondDragonLevel = tonumber(lines[4]) or 1, secondDragonGrade = tonumber(lines[5]) or 1 } end local function featureBattleArena() gg.setVisible(false) gg.clearResults() local userID = gg.prompt({"User ID:"}, nil, {"number"}) if not userID then return end local teamData = getTeamData(userID[1]) if not teamData then return end local selectedCode = teamData.dragonCode local datos = {teamData.firstDragonLevel, teamData.firstDragonGrade} local data = {teamData.secondDragonLevel, teamData.secondDragonGrade} gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS) gg.searchNumber(selectedCode .. ";" .. datos[1] .. ";" .. datos[2] .. ";" .. data[1] .. ";" .. data[2] .. "::133", gg.TYPE_DWORD) gg.refineNumber(selectedCode .. ";" .. datos[1] .. ";" .. datos[2] .. ";" .. data[1] .. "::101", gg.TYPE_DWORD) gg.refineNumber(selectedCode .. ";" .. datos[1] .. ";" .. datos[2] .. "::97", gg.TYPE_DWORD) gg.refineNumber(selectedCode .. ";" .. datos[1] .. "::37", gg.TYPE_DWORD) gg.refineNumber(selectedCode, gg.TYPE_DWORD) local t = gg.getResults(100) local valuesToFreeze = {} for i, v in ipairs(t) do gg.setValues({ {address = v.address + 0x0, flags = gg.TYPE_DWORD, value = 1011}, {address = v.address + 0x4, flags = gg.TYPE_DWORD, value = 1}, {address = v.address + 0x8, flags = gg.TYPE_DWORD, value = 0}, {address = v.address + 0x24, flags = gg.TYPE_DWORD, value = 0}, {address = v.address + 0x60, flags = gg.TYPE_DWORD, value = 1011}, {address = v.address + 0x64, flags = gg.TYPE_DWORD, value = 1}, {address = v.address + 0x68, flags = gg.TYPE_DWORD, value = 0}, {address = v.address + 0x84, flags = gg.TYPE_DWORD, value = 0}, {address = v.address + 0xC0, flags = gg.TYPE_DWORD, value = 1011}, {address = v.address + 0xC4, flags = gg.TYPE_DWORD, value = 1}, {address = v.address + 0xC8, flags = gg.TYPE_DWORD, value = 0}, {address = v.address + 0xE4, flags = gg.TYPE_DWORD, value = 0} }) table.insert(valuesToFreeze, {address = v.address + 0x0, flags = gg.TYPE_DWORD, value = 1011, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x4, flags = gg.TYPE_DWORD, value = 1, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x8, flags = gg.TYPE_DWORD, value = 0, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x24, flags = gg.TYPE_DWORD, value = 0, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x60, flags = gg.TYPE_DWORD, value = 1011, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x64, flags = gg.TYPE_DWORD, value = 1, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x68, flags = gg.TYPE_DWORD, value = 0, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0x84, flags = gg.TYPE_DWORD, value = 0, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0xC0, flags = gg.TYPE_DWORD, value = 1011, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0xC4, flags = gg.TYPE_DWORD, value = 1, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0xC8, flags = gg.TYPE_DWORD, value = 0, freeze = true}) table.insert(valuesToFreeze, {address = v.address + 0xE4, flags = gg.TYPE_DWORD, value = 0, freeze = true}) end if #valuesToFreeze > 0 then gg.addListItems(valuesToFreeze) gg.toast(string.format('Saved %d values to freeze list!', #valuesToFreeze), true) else gg.alert('No values found to freeze!') end gg.toast('Battle Arena modification complete!', true) gg.sleep(1500) end
local mainMenuItems = { "‚öîÔ∏è Battle Arena Mod", "üîì Unmod Battle Arena", "‚ùå Exit Script" } while true do gg.setVisible(false) gg.clearResults() local MD5 = gg.makeRequest("https://dragoncitynews.com/script/md5").content local choice = safeChoiceSearch(mainMenuItems, nil, "Dragon City Tools\ncoded by AnhLaManhDat\n" .. MD5) if choice == 1 then featureBattleArena() elseif choice == 2 then featureUnfreeze() -- Calls the new unfreeze feature elseif choice == 3 then gg.toast("Thanks for using! From ThjBeo With Love", false) break end gg.sleep(500) end gg.clearResults() gg.setVisible(false) os.exit()
